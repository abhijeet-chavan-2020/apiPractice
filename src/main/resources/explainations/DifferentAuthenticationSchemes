Basic, Bearer, Digest, OAuth1.0 and OAuth2.0
OAuth is meant for authorization and not for Authentication. OAuth 2.0 has different flows based on grant types.

Basic:
Client will send user name and password in Base64 encoded string in Authorization header. It is not secure.
Example: "Authorization": "Basic <encoded string>"
So in the postman, we can select Basic as Authorization type, provide username and password. Then in the headers tab, you can see a key and value pair added as:
Authorization : Basic <encoded string> . This encoded string is nothing but username and password encoded using Base64 encoding.

Digest:
This authentication scheme is based on challenge and response paradigm. That means, client sends request without username and password, then server sends some parameters like
Realm, Nonce and Algorithm. Using these parameter values, username and passwords are encrypted and Algorithms used can be of MD5, SHA-256, SHA512 etc.
And then the encrypted string is passed to the server. Server then decrypts this string and extract username and password for Authentication.

Bearer Authentication:
Bearer token is sent as Authorization Header. Bearer is a holder of the security token to get access to a certain resource. This is generated by the server in response to login request.
This generated Bearer token is then used to send the subsequent request to server to access the requested resources. Its created as part of OAuth2.0 spec.
Its passed in the Headers as Authorization header with Bearer value
Example: "Authorization":"Bearer <token>"

API Key:
Generated after login. Used as a replacement of username and password. That means, we need not to send username and password in http request. Rather it is generated after login to the application
Mostly in the Accounts Settings page or Accounts security section we can generate this key. Also, even if it is compromised, we can delete the existing key and generate the new one.
It is passed as a Header/ Query Parameter or even in the body. But its recommended to send in Headers with some key value like -
Example: "x-api-key":"AhgugugjV-AGYGUgb6464d-asdajks"
Its not secure.
In postman, we can generate an API key, then go to Authorization, select type= API Key, then enter key name, value as the API key generated, and add to section as Header.

OAuth:
OAuth is used for Authorization. For Authentication, OpenID Connect is used. Its a layer build on top of OAuth.
OAuth was originally created for Authorization purpose but people started using it for Authentication as well. So the need was there to create a standard for Authentication with OAuth.
With OAuth, we are authorizing a service so that it can use another service. To solve delegated authorization we are using OAuth.
What is Delegated Authorization: Suppose I am using appA which is used for photo editing. I edited the photo and now I want to upload that photo to Instagram, Google, Facebook etc.
So appA is providing a service to upload that photo to Google account. Using this service I can upload the photo to Google. But to do that, I need to Authorize my appA to access my Google account.
So after clicking on Google photos link, I will first Authenticate myself to Google Account, then allow appA to access my google account and then allow appA to view, download, upload my
photos. In this way we are allowing one service to access another services. This is called Delegated Authorization.

OpenID Connect:
Ini the above mentioned example, if appA is getting the access of the Google photo services then we will say that appA is authorized by Google to access the Google photos service.
But it is not authenticated to Google account. The Authentication part comes into picture in the following example.
Consider aapA has a login page where a new user can come and signup using Google. Whenever user clicks on Google option, an URL is created which indicate us what will happen during this sign up
using Google account. So appA can do the following 2 things:
appA can access user details from Google and store it in appA's DB and this way it will create account on their system. So next time whenever user comes to login page, then user can enter it email
address and password and can login easily.
In the second case, appA can take the user details from Google along with the Authorization to access the resources/ services but do not store the details in their DB and do not create user account
into their systems. This way the account maintenance cost and headache will be gone. In this case the URL created after clicking on Google account will have openId in it along with the scope
parameter.

OAuth Flows:
Here, client is appA, resource is the photo in Google photos, resource server is nothing but the server which hosts the photo of the user, resource owner is the owner who own the photo
on the Google photos.  Authorization server is generally couple with Resource server - it can be a separate entity or the part of the resource server itself. Its job is to issue the access token
to the client.

Authorization Code Grant Flow:
AUth Code/ Access Token. Refresh Token/ Token expiry/ Generating new token/
So here what happens is as the first step, the user logins to the Zoomin application, which is our client application.
And then here it tries to upload the photo. So the Zoomin application gives an option to upload the photo from the Google photos application if
the photo is available on this application. So if the photo is available on this application, then the user can select it. And then the zoom in application sends a request to the
authorization server on behalf of the user. So in this request, the Zoomin application sends some very important information to the authorization server.
For example, it sends something called as scope, which means the kind of access that is required by the Zoomin application on behalf of the resource that is the user.
So in this case, the requested access will be to view and download the photo that is available on the Google photos application.
So in this scope, the Zoomin application will inform the authorization server that it needs access to the photos, the user photos, and also some other vital information like the user email, the profile
photo and so on. So here the authorization server shows a login screen to the user wherein the user need to enter the username and the password.
And once the user is authenticated by the authorization server, the authorization server. Will request the user to give permission to the client application that is the zoom in application.
And while doing so, it will basically show some information, some vital information to the user.
For example, the kind of permission that is requested by the client application. In this case, the permission will be to view and download the photos and it could also be the user
email address or the user profile photo and so on. And it will also ask the user whether the user trust the Zoomin application.
So only if the user gives a go ahead by allowing the access the authorization server. Then sends something called as the auth code back to the zoom in application.
The client application. Now the auth code is a short lived token that can be used by the client application. So here notice that all this flow is happening on the front end channel that is from the browser.
All the information that is being transferred is visible to everyone and that is fine because here the information that is available that does not really need to be secure.
So from here on, once the zooming application gets the auth code, the backend channel of the zooming application, that is the backend server.
It will send the auth code back to the authorization server. The authorization server will validate the auth code and only if it is valid then it will send back
something called as the access token and in some cases the refresh token back to the client application. Now again, the access token is a short lived token, so it will have an expiry time.
It can be 15 minutes or 30 minutes or one hour. And here the refresh token is something that remains valid until the user is logged in on the browser, until the login session is active.
So what happens is once the access token is expired, the client application can use the refresh token to renew a new access token as long as the refresh token is valid.
If the refresh token itself is not valid, that is if the user logged out of the Google photos application. Then all this process will have to be repeated.
Now, once the zoom in backend server gets the access token, it can send the access token back to the Google photos application to request for the photo to request for the resource.
And it will send the access token as part of the API call. That will be sent to the Google photos application. In this case, the API call will be for the photos for fetching the photos.
The Google photos application will then validate the access token and only if it is valid then it will send back the photo back to the zoom in application.
 So with this, the zoom in application has got access to the protected resource that is the photo. And it got access on behalf of the resource owner because the resource owner authorized the Zoomin application
to access the photo. As simple as that. And here, observe that the auth code and the access token and the refresh token, all this information is happening on the back end channel.
So this is not exposed to everyone. And since it is happening on the back end channel, it is secure. Right. So that is why the authorization grant flow is the most secure way of the delegated authorization,
because here some communication is partially happening on the front end channel, which is kind of visible to everyone. And some communication is happening on the back end channel, which is not visible to everyone.
It is happening securely. So usually this flow is used for the web server application. Basically any web application which has got a front end as well as a back end.

Implicit Grant Flow:
No Auth code is generated in this scenario. Client request for specific grant type which is scope. And Authorization server directly gives Access token to client. Client then
uses this Access token to fetch the resources form the Resource server. This way is not secured. Because everything is happening on front end only. That means on the browser and the
access token is exposed to the browser. The Access Token in this case is short lived to make it secure. The applications that do not have the backend server that do not have the
backend channel. So the JavaScript that runs through the browser basically triggers this flow for getting the access token.
The access token is then stored in the browser and then it is used for making the API call to the server.

Client Credentials flow:
Now, the fundamental difference between this flow and the other two flows that we discussed, that is the authorization grant flow. And the implicit grant flow is that in this flow there is no user involved, there are only services
involved. One service can act as the client and the another service can act as the auth server. okay. And since there are only services involved in this flow and no user involved, this is a perfect fit
for the microservice architecture in the microservice architecture. There can be multiple services that communicates with each other to perform certain tasks.
In that case, you might not want each service to have access to all the resources from the other services. You might want to restrict that access. So in that case you can use the client credentials flow because it authorizes the service for itself
to get an access on the resource that is hosted by another service. So in this case, it is very important that the client is super duper trusted by the auth server and
this is only possible if both the client and the server are created by you, right, by the same entity. And that is applicable in case of microservice architecture, right?
Because all the services are developed by the same architect. So all the services are trusting each other and in that case they can use the client credentials flow
without any security issue because the services trust each other implicitly. So let us have a look at one example. So let us say there are two services, the service one and the service two.
And here the service one implements two different APIs. The one API gives the user profile information like the user email, the user address the phone number and so on.
And there is another API that gives the information on the user activities. Now let us say this Service two want to leverage the API that gives the information on the user activities
and not the API that gives the information on the user profile. So the service two is not meant to have access on the API that gives the user profile information.
So in that case the service two can be authorized only to get an access on the API from service, one that gives the information on the user activities and this can be achieved using the authorization server.
So here what happens is the service two sends the client ID and the client secret to the authorization server. Now here the client ID is unique to the service.
If there is another service, it will have another client ID. Okay. And typically client ID is public, it is exposed and the client secret is something which is private
to the service. It is not supposed to be exposed. So the combination of the client ID and the client secret is sent to the authorization server.
The authorization server validates this information, validates that the request is coming from the correct client, right? And only after the validation it sends back something called as the access token to the client to this
service. So the access token is the short lived token. That is, it will have an expiry time. It can expire in five minutes or 15 minutes or 30 minutes.
So the service two will hold on the access token and then it will send the access token to the service one to get an access on the API that gives the information on the user activities.
So the service one will validate the access token and only if it finds that service two is requesting for the access for the API it is supposed to have access on.
Then it will send back the requested information to the service two. As simple as that. If service one finds that, service two is requesting for access on the API that gives the information
on user profile, then it will reject this access token. Okay, so the access token will carry all the information that is required by the service one to validate
the request from service two. So once the service to gets the required access on the API, it can fetch the information on the user activities.
So that's about the client credentials flow. And the important point to note is that it is very useful in case of microservice architecture, right?
In case of one service communicating with another service that is, there is no user involved.
In the header of the request, client is requesting to access an URL/ another service, so Content-type will be x-www-form-urlencoded.